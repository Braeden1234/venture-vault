<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading…</title>
  <link rel="preconnect" href="https://docs.google.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://docs.googleusercontent.com">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/sass.js@0.11.1/dist/sass.sync.min.js" as="script">

  <!-- Rise Vision Player API -->
  <script src="https://widgets.risevision.com/stable/templates/src/rise-player-configuration.js"></script>

  <style>
    body { margin: 0; background: #000; }
    #vv-overlay {
      position: fixed;
      inset: 0;
      z-index: 999999;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 18px;
      transition: opacity 0.5s ease;
    }
    #vv-overlay.fade { opacity: 0; pointer-events: none; }
    #vv-spinner {
      width: 36px;
      height: 36px;
      border: 3px solid rgba(213,159,15,0.2);
      border-top-color: #D59F0F;
      border-radius: 50%;
      animation: vv-spin 0.8s linear infinite;
    }
    #vv-status {
      color: rgba(213,159,15,0.7);
      font-family: monospace;
      font-size: 12px;
      letter-spacing: .1em;
    }
    @keyframes vv-spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="vv-overlay">
    <div id="vv-spinner"></div>
    <div id="vv-status">loading…</div>
  </div>

<script>
  // ── CONFIG ────────────────────────────────────────────────────────────────────
  const DOC_ID    = '1LXh4gM2EIcpIvfVmV6F38g3dl8TpjQG_vyecAOa3Dw0';
  const PROJECT   = 'MainDisplay';
  const INDEX_TAB = '0';
  const POLL_MS   = 1000;

  // ── Rise Vision Integration ───────────────────────────────────────────────────
  // Signals Rise Vision player that content is ready to display.
  // Safe to call even if not inside Rise Vision (postMessage is ignored outside).
  function riseReady() {
    try {
      if (window.RiseVision && typeof window.RiseVision.ready === 'function') {
        window.RiseVision.ready();
      }
    } catch(e) {}
    // Modern Rise Vision player listens for this postMessage
    try { window.parent.postMessage('rise-presentation-ready', '*'); } catch(e) {}
    try { window.postMessage('rise-presentation-ready', '*'); } catch(e) {}
  }

  // Handle play/pause/stop events from the Rise Vision player
  window.addEventListener('rise-presentation-play',  function() { document.body.style.visibility = 'visible'; });
  window.addEventListener('rise-presentation-stop',  function() { document.body.style.visibility = 'hidden'; });
  window.addEventListener('rise-presentation-pause', function() { /* optional: pause animations */ });

  // ── Safe sessionStorage wrapper ───────────────────────────────────────────────
  // Rise Vision's sandboxed player may block or throw on sessionStorage.
  // All cache reads/writes go through these helpers to avoid crashes.
  const store = {
    get: function(key) {
      try { return sessionStorage.getItem(key); } catch(e) { return null; }
    },
    set: function(key, val) {
      try { sessionStorage.setItem(key, val); } catch(e) {}
    }
  };

  // ── ATC_Map parser ────────────────────────────────────────────────────────────
  function parseATCMap(text) {
    const clean = text
      .replace(/[\u2018\u2019]/g, "'")
      .replace(/[\u201C\u201D]/g, '"')
      .replace(/(?<![\w])([_*]+)|([_*]+)(?![\w])/g, '')
      .replace(/\r\n/g, '\n');

    function extractBraceBlock(src, fromIndex) {
      const open = src.indexOf('{', fromIndex);
      if (open === -1) return null;
      let depth = 0, end = -1;
      for (let i = open; i < src.length; i++) {
        if (src[i] === '{') depth++;
        else if (src[i] === '}') { if (--depth === 0) { end = i; break; } }
      }
      return end === -1 ? null : { body: src.slice(open + 1, end), open, end };
    }

    const atcStart = clean.indexOf('ATC_Map');
    if (atcStart === -1) return null;
    const atcBlock = extractBraceBlock(clean, atcStart);
    if (!atcBlock) return null;

    const pctStart = atcBlock.body.indexOf('%');
    if (pctStart === -1) return null;
    const filesBlock = extractBraceBlock(atcBlock.body, pctStart);
    if (!filesBlock) return null;
    const fb = filesBlock.body;

    if (/\(\s*Folder\s*\)/i.test(fb)) {
      const folderMap = {};
      for (const m of fb.matchAll(/\.(\w+)\(@([^)]+)\)/g))
        folderMap[m[1]] = m[2];
      return { folderMap };
    }

    const fileMap    = {};
    let htmlFilename = null;
    const ftRe       = /\$\s*FileType\s*\(([^)]+)\)((?:\s*#\w+)*)\s*\{/g;
    let fm;
    while ((fm = ftRe.exec(fb)) !== null) {
      const ext     = fm[1].trim().toLowerCase();
      const isIndex = fm[2].toUpperCase().includes('#INDEX');
      const bodyStart = fm.index + fm[0].length;
      let depth = 1, be = -1;
      for (let i = bodyStart; i < fb.length; i++) {
        if (fb[i] === '{') depth++;
        else if (fb[i] === '}') { if (--depth === 0) { be = i; break; } }
      }
      if (be === -1) continue;
      const body = fb.slice(bodyStart, be);
      for (const em of body.matchAll(/\.(\w+)\(@([^)]+)\)/g)) {
        const filename = `${em[1]}.${ext}`;
        fileMap[filename] = em[2];
        if (isIndex) htmlFilename = filename;
      }
    }
    return { fileMap, htmlFilename };
  }

  // ── Parse @section directives ─────────────────────────────────────────────────
  function parseSections(jsText) {
    const sections = [];
    const lines    = jsText.split('\n');
    let current    = null;
    let buffer     = [];

    for (const line of lines) {
      const trimmed    = line.trim();
      const openMatch  = trimmed.match(/^\/\/\s*@section:(\S+)/);
      const closeMatch = trimmed.match(/^\/\/\s*@\/section/);

      if (openMatch) {
        if (buffer.length && buffer.join('\n').trim())
          sections.push({ type: 'main', code: buffer.join('\n') });
        buffer  = [];
        current = openMatch[1];
      } else if (closeMatch && current) {
        sections.push({ type: current, code: buffer.join('\n') });
        buffer  = [];
        current = null;
      } else {
        buffer.push(line);
      }
    }
    if (buffer.length && buffer.join('\n').trim())
      sections.push({ type: current || 'main', code: buffer.join('\n') });
    return sections;
  }

  function runScript(code) {
    const s = document.createElement('script');
    s.textContent = code;
    document.head.appendChild(s);
  }

  // ── Overlay helpers ───────────────────────────────────────────────────────────
  function setStatus(msg) {
    const el = document.getElementById('vv-status');
    if (el) el.textContent = msg;
  }

  function hideOverlay() {
    const el = document.getElementById('vv-overlay');
    if (!el) return;
    el.classList.add('fade');
    setTimeout(function() { if (el.parentNode) el.parentNode.removeChild(el); }, 550);
    // Signal Rise Vision that we're ready to be displayed
    riseReady();
  }

  // Poll until #mainContent has real content, then hide overlay
  function waitForContent(tries) {
    tries = tries || 0;
    const mc = document.getElementById('mainContent');
    if (mc && mc.children.length > 0 && !mc.querySelector('.loading-state')) {
      hideOverlay();
      return;
    }
    // Fallback: if there's no #mainContent element, consider content ready after
    // all scripts have run (DOM has been populated by the loaded app).
    if (tries > 10 && !document.getElementById('mainContent')) {
      hideOverlay();
      return;
    }
    if (tries > 200) { hideOverlay(); return; } // 10s max
    setTimeout(function() { waitForContent(tries + 1); }, 50);
  }

  const SECTION_READY = {
    'paperjs': function() { return !!(window.paper && window.paper.PaperScope); }
  };

  function waitFor(readyFn, fn, tries) {
    tries = tries || 0;
    if (readyFn()) { fn(); return; }
    if (tries > 100) { console.warn('[loader] timed out waiting for section'); return; }
    setTimeout(function() { waitFor(readyFn, fn, tries + 1); }, 50);
  }

  function runSection(section) {
    const readyFn = SECTION_READY[section.type];
    if (readyFn) waitFor(readyFn, function() { runScript(section.code); });
    else runScript(section.code);
  }

  // ── Sass compiler ─────────────────────────────────────────────────────────────
  let _sassReady = false;
  let _sassQueue = [];

  function loadSass(fn) {
    if (_sassReady) { fn && fn(); return; }
    if (fn) _sassQueue.push(fn);
    if (_sassQueue.length > 1 || (!fn && _sassQueue.length > 0)) return;
    const s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/sass.js@0.11.1/dist/sass.sync.min.js';
    s.onload = function() {
      _sassReady = true;
      _sassQueue.forEach(function(cb) { cb(); });
      _sassQueue = [];
    };
    s.onerror = function() { console.warn('[loader] sass.js failed to load'); };
    document.head.appendChild(s);
  }
  loadSass(null);

  function compileSass(scss, cb) {
    loadSass(function() {
      Sass.compile(scss, function(result) {
        if (result.status === 0) cb(null, result.text);
        else { console.warn('[loader] Sass compile error:', result.message); cb(result.message, scss); }
      });
    });
  }

  // ── Inline local CSS/JS into HTML ────────────────────────────────────────────
  function buildFromContents(htmlContent, contents) {
    let result = htmlContent;
    for (const m of [...htmlContent.matchAll(/<link\b[^>]*\bhref=["']([^"'#][^"']*)["'][^>]*>/gi)]) {
      const fullTag = m[0], href = m[1];
      if (/^https?:\/\//i.test(href) || !contents[href]) continue;
      if (href.toLowerCase().endsWith('.scss')) {
        result = result.split(fullTag).join(`<script type="text/vv-scss">${contents[href]}<\/script>`);
      } else {
        result = result.split(fullTag).join(`<style>/* ${href} */\n${contents[href]}\n</style>`);
      }
    }
    for (const m of [...result.matchAll(/<script\b([^>]*)\bsrc=["']([^"']+)["'][^>]*>\s*<\/script>/gi)]) {
      const fullTag = m[0], src = m[2];
      if (/^https?:\/\//i.test(src) || !contents[src]) continue;
      result = result.split(fullTag).join(
        `<script type="text/vv-module" data-name="${src}">\n${contents[src]}\n<\/script>`
      );
    }
    return result;
  }

  // ── Apply HTML to the page ────────────────────────────────────────────────────
  function applyHTML(inlinedHTML, filename, silent) {
    const doc = new DOMParser().parseFromString(inlinedHTML, 'text/html');
    document.title          = doc.title || filename || PROJECT;
    document.head.innerHTML = '';
    doc.head.querySelectorAll(':not(script)').forEach(el =>
      document.head.appendChild(el.cloneNode(true))
    );
    document.body.innerHTML = '';
    [...doc.body.attributes].forEach(a => document.body.setAttribute(a.name, a.value));
    document.body.innerHTML = doc.body.innerHTML;

    if (!silent) {
      const _overlay = document.createElement('div');
      _overlay.id = 'vv-overlay';
      _overlay.innerHTML = '<div id="vv-spinner"></div><div id="vv-status">building…</div>';
      _overlay.style.cssText = 'position:fixed;inset:0;z-index:999999;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;transition:opacity 0.5s ease;';
      const _spinner  = _overlay.querySelector('#vv-spinner');
      _spinner.style.cssText  = 'width:36px;height:36px;border:3px solid rgba(213,159,15,0.2);border-top-color:#D59F0F;border-radius:50%;animation:vv-spin 0.8s linear infinite;';
      const _statusEl = _overlay.querySelector('#vv-status');
      _statusEl.style.cssText = 'color:rgba(213,159,15,0.7);font-family:monospace;font-size:12px;letter-spacing:.1em;';
      document.body.appendChild(_overlay);
    }

    const allScripts = [
      ...doc.head.querySelectorAll('script'),
      ...doc.body.querySelectorAll('script')
    ];

    function runNext(i) {
      if (i >= allScripts.length) { waitForContent(); return; }
      const orig = allScripts[i];
      const type = orig.getAttribute('type') || '';

      if (type === 'text/vv-scss') {
        setStatus('compiling styles…');
        compileSass(orig.textContent, function(err, css) {
          const style = document.createElement('style');
          style.textContent = css;
          document.head.appendChild(style);
          setStatus('loading scripts…');
          runNext(i + 1);
        });
      } else if (type === 'text/vv-module') {
        parseSections(orig.textContent).forEach(runSection);
        runNext(i + 1);
      } else if (orig.src) {
        const s = document.createElement('script');
        s.src     = orig.src;
        s.onload  = () => runNext(i + 1);
        s.onerror = () => runNext(i + 1);
        document.head.appendChild(s);
      } else {
        runScript(orig.textContent);
        runNext(i + 1);
      }
    }
    runNext(0);
  }

  // ── Fetch helpers ─────────────────────────────────────────────────────────────
  async function fetchTab(tabId) {
    const id  = String(tabId).replace(/^t\./, '');
    const url = `https://docs.google.com/document/d/${DOC_ID}/export?format=txt&tab=t.${id}&cachebust=${Date.now()}`;
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for tab t.${id}`);
    return (await res.text()).replace(/^\uFEFF/, '').trim();
  }

  async function fetchAllFiles(fileMap, fallback) {
    return Promise.all(
      Object.keys(fileMap).map(name =>
        fetchTab(fileMap[name])
          .then(content => ({ name, content }))
          .catch(() => ({ name, content: (fallback && fallback[name]) || '' }))
      )
    );
  }

  function hashStr(s) {
    let h = 0;
    for (let i = 0; i < s.length; i++) h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;
    return h;
  }

  let _fileMap      = {};
  let _contents     = {};
  let _hashes       = {};
  let _htmlFilename = '';
  let _pollUpdating = false;

  async function pollForChanges() {
    if (_pollUpdating) return;
    _pollUpdating = true;
    try {
      const fetched = await fetchAllFiles(_fileMap, _contents);
      const freshHashes = {};
      let changed = false;
      fetched.forEach(f => {
        freshHashes[f.name] = hashStr(f.content);
        if (freshHashes[f.name] !== _hashes[f.name]) changed = true;
      });
      if (!changed) return;

      console.log('[hotreload] change detected — rebuilding');
      const freshContents = {};
      fetched.forEach(f => {
        freshContents[f.name] = f.content;
        _contents[f.name]     = f.content;
        _hashes[f.name]       = freshHashes[f.name];
      });
      const htmlContent = freshContents[_htmlFilename];
      if (!htmlContent) return;
      applyHTML(buildFromContents(htmlContent, freshContents), _htmlFilename, true);
    } catch(e) {
      console.warn('[hotreload]', e.message);
    } finally {
      _pollUpdating = false;
    }
  }

  const CACHE_KEY     = 'vv_filemap_'  + PROJECT;
  const CACHE_KEY_CON = 'vv_contents_' + PROJECT;

  const _prefetchDir = fetchTab(INDEX_TAB);

  async function resolveFileMap() {
    try {
      const cached = store.get(CACHE_KEY);
      if (cached) {
        const { fileMap, htmlFilename } = JSON.parse(cached);
        console.log('[loader] file map from cache');
        return { fileMap, htmlFilename };
      }
    } catch(e) {}

    const dirParsed = parseATCMap(await _prefetchDir);
    if (!dirParsed || !dirParsed.folderMap)
      throw new Error('Could not parse Directory ATC_Map');
    const projectTabId = dirParsed.folderMap[PROJECT];
    if (!projectTabId)
      throw new Error(`"${PROJECT}" not found in Directory`);

    const projParsed = parseATCMap(await fetchTab(projectTabId));
    if (!projParsed || !projParsed.fileMap)
      throw new Error(`Could not parse project ATC_Map for "${PROJECT}"`);
    const { fileMap, htmlFilename } = projParsed;
    if (!htmlFilename)
      throw new Error(`No #INDEX HTML entry found for "${PROJECT}"`);

    store.set(CACHE_KEY, JSON.stringify({ fileMap, htmlFilename }));
    return { fileMap, htmlFilename };
  }

  async function boot() {
    try {
      const { fileMap, htmlFilename } = await resolveFileMap();
      _htmlFilename = htmlFilename;

      // ── Try cache for instant first paint ──────────────────────────────────
      let servedFromCache = false;
      try {
        const cachedCon = store.get(CACHE_KEY_CON);
        if (cachedCon) {
          const allContents = JSON.parse(cachedCon);
          if (allContents[htmlFilename]) {
            console.log('[loader] contents from cache — instant render');
            _fileMap = fileMap;
            Object.assign(_contents, allContents);
            Object.keys(allContents).forEach(k => _hashes[k] = hashStr(allContents[k]));
            applyHTML(buildFromContents(allContents[htmlFilename], allContents), htmlFilename);
            setInterval(pollForChanges, POLL_MS);
            servedFromCache = true;
          }
        }
      } catch(e) {}

      if (servedFromCache) {
        // Refresh cache in background for next load
        fetchAllFiles(fileMap, {}).then(fetched => {
          const fresh = {};
          fetched.forEach(f => { fresh[f.name] = f.content; });
          store.set(CACHE_KEY_CON, JSON.stringify(fresh));
        });
        return;
      }

      // ── Cold start ─────────────────────────────────────────────────────────
      const fetched = await fetchAllFiles(fileMap, {});
      const allContents = {};
      fetched.forEach(f => {
        allContents[f.name] = f.content;
        _contents[f.name]   = f.content;
        _hashes[f.name]     = hashStr(f.content);
      });
      _fileMap = fileMap;

      store.set(CACHE_KEY_CON, JSON.stringify(allContents));

      setStatus('fetching styles…');
      applyHTML(buildFromContents(allContents[htmlFilename], allContents), htmlFilename);
      setInterval(pollForChanges, POLL_MS);
      console.log(`[deploy] "${PROJECT}" live — polling every ${POLL_MS / 1000}s`);
    } catch(e) {
      document.body.innerHTML = `
        <div style="color:#e07070;font-family:monospace;padding:40px;background:#0c0e12;min-height:100vh">
          <b>⚠ ${e.message}</b><br><br>
          <span style="color:#555">Check the doc is shared as "Anyone with the link — Viewer"</span>
        </div>`;
      // Still signal ready so Rise Vision doesn't wait forever
      riseReady();
    }
  }

  boot();
</script>
</body>
</html>
