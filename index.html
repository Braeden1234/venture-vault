<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading…</title>
  <style>
    body {
      margin: 0;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    #splash {
      color: #888;
      font-family: monospace;
      font-size: 13px;
      letter-spacing: .05em;
    }
  </style>
</head>

<body>
  <div id="splash">loading…</div>
  <script>
    const DOC_ID = '1LXh4gM2EIcpIvfVmV6F38g3dl8TpjQG_vyecAOa3Dw0';
    const PROJECT = 'MainDisplay';
    const INDEX_TAB = '0';
    const POLL_MS = 5000;
    async function fetchTab(tabId) {
      const id = String(tabId).replace(/^t\./, '');
      const url = `https://docs.google.com/document/d/${DOC_ID}/export?format=txt&tab=t.${id}&cachebust=${Date.now()}`;
      const res = await fetch(url, {
        cache: 'no-store'
      });
      if (!res.ok) throw new Error(`HTTP ${res.status} for tab t.${id}`);
      return (await res.text()).replace(/^\uFEFF/, '').trim();
    }

    function parseKV(text) {
      const map = {};
      for (const raw of text.split('\n')) {
        const line = raw.trim().replace(/^[_*]+|[_*]+(?==)/g, '');
        if (!line || line.startsWith('#') || line.startsWith('//')) continue;
        const eq = line.indexOf('=');
        if (eq < 1) continue;
        const k = line.slice(0, eq).trim().replace(/^[_*]+|[_*]+$/g, '');
        const v = line.slice(eq + 1).trim().replace(/^[_*]+|[_*]+$/g, '');
        if (k && v) map[k] = v;
      }
      return map;
    }

    function parseSections(jsText) {
      const sections = [];
      const lines = jsText.split('\n');
      let current = null;
      let buffer = [];
      for (const line of lines) {
        const trimmed = line.trim();
        const openMatch = trimmed.match(/^\/\/\s*@section:(\S+)/);
        const closeMatch = trimmed.match(/^\/\/\s*@\/section/);
        if (openMatch) {
          // Save any buffered code before this section as 'main'
          if (buffer.length && buffer.join('\n').trim()) {
            sections.push({
              type: 'main',
              code: buffer.join('\n')
            });
          }
          buffer = [];
          current = openMatch[1]; // 'main' | 'paperjs' | etc
        } else if (closeMatch && current) {
          sections.push({
            type: current,
            code: buffer.join('\n')
          });
          buffer = [];
          current = null;
        } else {
          buffer.push(line);
        }
      }
      // Remaining buffer after last section
      if (buffer.length && buffer.join('\n').trim()) {
        sections.push({
          type: current || 'main',
          code: buffer.join('\n')
        });
      }
      return sections;
    }
    // ── Run a script block by injecting it into the document ────────────────────
    function runScript(code) {
      const s = document.createElement('script');
      s.textContent = code;
      document.head.appendChild(s);
    }

    function resolvePath(path) {
      return path.split('.').reduce(function(obj, key) {
        return obj && obj[key];
      }, window);
    }

    function waitFor(dotPath, fn, tries) {
      tries = tries || 0;
      if (resolvePath(dotPath)) {
        fn();
        return;
      }
      if (tries > 100) {
        console.warn('[loader] timed out waiting for', dotPath);
        return;
      }
      setTimeout(function() {
        waitFor(dotPath, fn, tries + 1);
      }, 50);
    }

    function runSection(section) {
      if (section.type.indexOf('wait:') === 0) {
        waitFor(section.type.slice(5), function() {
          runScript(section.code);
        });
      } else {
        runScript(section.code);
      }
    }
    // ── Inline local CSS/JS into the HTML ───────────────────────────────────────
    function buildFromContents(htmlContent, contents) {
      let result = htmlContent;
      // Inline local CSS files
      for (const m of [...htmlContent.matchAll(/<link\b[^>]*\bhref=["']([^"'#][^"']*)["'][^>]*>/gi)]) {
        const fullTag = m[0],
          href = m[1];
        if (/^https?:\/\//i.test(href) || !contents[href]) continue;
        result = result.split(fullTag).join(`<style>/* ${href} */\n${contents[href]}\n</style>`);
      }
      // Inline local JS files — but store them as data attributes so we can
      // parse their @section directives at runtime instead of just running them
      for (const m of [...result.matchAll(/<script\b([^>]*)\bsrc=["']([^"']+)["'][^>]*>\s*<\/script>/gi)]) {
        const fullTag = m[0],
          src = m[2];
        if (/^https?:\/\//i.test(src) || !contents[src]) continue;
        // Wrap in a special marker script so applyHTML can find and section-parse it
        result = result.split(fullTag).join(
          `<script type="text/vv-module" data-name="${src}">\n${contents[src]}\n<\/script>`
        );
      }
      return result;
    }
    // ── Apply built HTML to the page, respecting @section directives ─────────────
    function applyHTML(inlinedHTML, filename) {
      const doc = new DOMParser().parseFromString(inlinedHTML, 'text/html');
      document.title = doc.title || filename || PROJECT;
      document.head.innerHTML = '';
      doc.head.querySelectorAll(':not(script)').forEach(el =>
        document.head.appendChild(el.cloneNode(true))
      );
      document.body.innerHTML = '';
      [...doc.body.attributes].forEach(a => document.body.setAttribute(a.name, a.value));
      document.body.innerHTML = doc.body.innerHTML;
      // Collect all scripts in DOM order
      const allScripts = [
        ...doc.head.querySelectorAll('script'),
        ...doc.body.querySelectorAll('script')
      ];

      function runNext(i) {
        if (i >= allScripts.length) return;
        const orig = allScripts[i];
        const type = orig.getAttribute('type') || '';
        if (type === 'text/vv-module') {
          // Our JS file — parse @section directives and run each chunk correctly
          const sections = parseSections(orig.textContent);
          sections.forEach(function(sec) {
            runSection(sec);
          });
          runNext(i + 1);
        } else if (orig.src) {
          // External CDN script — load it, then continue
          const s = document.createElement('script');
          s.src = orig.src;
          s.onload = () => runNext(i + 1);
          s.onerror = () => runNext(i + 1);
          document.head.appendChild(s);
        } else {
          // Normal inline script
          runScript(orig.textContent);
          runNext(i + 1);
        }
      }
      runNext(0);
    }
    async function fetchAllFiles(fileMap, fallback) {
      return Promise.all(
        Object.keys(fileMap).map(name =>
          fetchTab(fileMap[name])
          .then(content => ({
            name,
            content
          }))
          .catch(() => ({
            name,
            content: (fallback && fallback[name]) || ''
          }))
        )
      );
    }

    function hashStr(s) {
      let h = 0;
      for (let i = 0; i < s.length; i++) h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;
      return h;
    }
    let _fileMap = {};
    let _contents = {};
    let _hashes = {};
    let _htmlFilename = '';
    let _pollUpdating = false;
    async function pollForChanges() {
      if (_pollUpdating) return;
      _pollUpdating = true;
      try {
        const projectTab = parseKV(await fetchTab(INDEX_TAB))[PROJECT];
        if (!projectTab) return;
        const freshMap = parseKV(await fetchTab(projectTab));
        const fetched = await fetchAllFiles(freshMap, _contents);
        const freshHashes = {};
        let changed = false;
        fetched.forEach(f => {
          freshHashes[f.name] = hashStr(f.content);
          if (freshHashes[f.name] !== _hashes[f.name]) changed = true;
        });
        if (Object.keys(freshMap).sort().join('|') !== Object.keys(_fileMap).sort().join('|')) changed = true;
        if (!changed) return;
        console.log('[hotreload] change detected — rebuilding');
        const freshContents = {};
        fetched.forEach(f => {
          freshContents[f.name] = f.content;
          _contents[f.name] = f.content;
          _hashes[f.name] = freshHashes[f.name];
        });
        _fileMap = freshMap;
        const htmlContent = freshContents[_htmlFilename];
        if (!htmlContent) return;
        applyHTML(buildFromContents(htmlContent, freshContents), _htmlFilename);
      } catch (e) {
        console.warn('[hotreload]', e.message);
      } finally {
        _pollUpdating = false;
      }
    }
    async function boot() {
      try {
        const projectTab = parseKV(await fetchTab(INDEX_TAB))[PROJECT];
        if (!projectTab) throw new Error(`"${PROJECT}" not found`);
        const fileMap = parseKV(await fetchTab(projectTab));
        const htmlFilename = Object.keys(fileMap).find(n => n.toLowerCase().endsWith('.html'));
        if (!htmlFilename) throw new Error(`No .html in "${PROJECT}"`);
        _htmlFilename = htmlFilename;
        const fetched = await fetchAllFiles(fileMap, {});
        const allContents = {};
        fetched.forEach(f => {
          allContents[f.name] = f.content;
          _contents[f.name] = f.content;
          _hashes[f.name] = hashStr(f.content);
        });
        _fileMap = fileMap;
        applyHTML(buildFromContents(allContents[htmlFilename], allContents), htmlFilename);
        setInterval(pollForChanges, POLL_MS);
        console.log(`[deploy] "${PROJECT}" live — polling every ${POLL_MS/1000}s`);
      } catch (e) {
        document.body.innerHTML = `
        <div style="color:#e07070;font-family:monospace;padding:40px;background:#0c0e12;min-height:100vh">
          <b>⚠ ${e.message}</b><br><br>
          <span style="color:#555">Check the doc is shared as "Anyone with the link — Viewer"</span>
        </div>`;
      }
    }
    boot();
  </script>
</body>

</html>
