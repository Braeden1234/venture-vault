<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading&#8230;</title>
  <link rel="preconnect" href="https://docs.google.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/sass.js@0.11.1/dist/sass.sync.min.js" as="script">
  <style>
    body { margin: 0; background: #000; }
    #vv-overlay {
      position: fixed; inset: 0; z-index: 999999; background: #000;
      display: flex; flex-direction: column; align-items: center;
      justify-content: center; gap: 18px; transition: opacity 0.5s ease;
    }
    #vv-overlay.fade { opacity: 0; pointer-events: none; }
    #vv-spinner {
      width: 36px; height: 36px;
      border: 3px solid rgba(213,159,15,0.2);
      border-top-color: #D59F0F; border-radius: 50%;
      animation: vv-spin 0.8s linear infinite;
    }
    #vv-status { color: rgba(213,159,15,0.7); font-family: monospace; font-size: 12px; letter-spacing: .1em; }
    @keyframes vv-spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="vv-overlay">
    <div id="vv-spinner"></div>
    <div id="vv-status">loading&#8230;</div>
  </div>

<script>
  // ── CONFIG ──────────────────────────────────────────────────────────────────
  const DOC_ID    = '1LXh4gM2EIcpIvfVmV6F38g3dl8TpjQG_vyecAOa3Dw0';
  const PROJECT   = 'MainDisplay';
  const INDEX_TAB = '0';
  const POLL_MS   = 1000;

  // ── sessionStorage wrapper ──────────────────────────────────────────────────
  const store = {
    get: function(k) { try { return sessionStorage.getItem(k); } catch(e) { return null; } },
    set: function(k,v){ try { sessionStorage.setItem(k,v);     } catch(e) {} }
  };

  // ── ATC_Map parser ──────────────────────────────────────────────────────────
  // Uses slice-between-projects instead of brace-counting so Google Docs
  // export artefacts (line numbers, stray chars) cannot break it.
  function parseATCMap(text, projectName) {
    const clean = text
      .replace(/[\u2018\u2019]/g, "'")
      .replace(/[\u201C\u201D]/g, '"')
      .replace(/\r\n|\r/g, '\n')
      .replace(/\*{1,3}([^*\n]+)\*{1,3}/g, '$1')  // strip bold/italic
      .replace(/_{1,3}([^_\n]+)_{1,3}/g,   '$1');

    // Find "$ Project (Name)"
    const esc        = projectName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    const startRe    = new RegExp('\\$\\s*Project\\s*\\(\\s*' + esc + '\\s*\\)');
    const startMatch = startRe.exec(clean);
    if (!startMatch) return null;

    // Slice to next "$ Project (" so we never bleed into another project
    const after        = clean.slice(startMatch.index + startMatch[0].length);
    const nextProj     = after.search(/\$\s*Project\s*\(/);
    const projectSlice = nextProj === -1 ? after : after.slice(0, nextProj);

    // Extract every: % FileType (EXT) [#INDEX] { .Name(@tabId); }
    // FileType bodies never have nested braces, so [^}]* is safe.
    const fileMap    = {};
    let   htmlFn     = null;
    const ftRe       = /%\s*FileType\s*\(([^)]+)\)((?:\s*#\w+)*)[^{]*\{([^}]*)\}/g;
    let   fm;
    while ((fm = ftRe.exec(projectSlice)) !== null) {
      const ext     = fm[1].trim().toLowerCase();
      const isIndex = fm[2].toUpperCase().includes('#INDEX');
      for (const em of fm[3].matchAll(/\.(\w+)\(@([^)]+)\)/g)) {
        const fn      = em[1] + '.' + ext;
        fileMap[fn]   = em[2].trim();
        if (isIndex) htmlFn = fn;
      }
    }

    if (!Object.keys(fileMap).length) return null;
    return { fileMap, htmlFilename: htmlFn };
  }

  // ── @section parser ─────────────────────────────────────────────────────────
  function parseSections(jsText) {
    const sections = []; const lines = jsText.split('\n');
    let cur = null; let buf = [];
    for (const line of lines) {
      const t  = line.trim();
      const om = t.match(/^\/\/\s*@section:(\S+)/);
      const cm = t.match(/^\/\/\s*@\/section/);
      if (om) {
        if (buf.length && buf.join('\n').trim()) sections.push({ type: 'main', code: buf.join('\n') });
        buf = []; cur = om[1];
      } else if (cm && cur) {
        sections.push({ type: cur, code: buf.join('\n') }); buf = []; cur = null;
      } else { buf.push(line); }
    }
    if (buf.length && buf.join('\n').trim()) sections.push({ type: cur || 'main', code: buf.join('\n') });
    return sections;
  }

  function runScript(code) { const s = document.createElement('script'); s.textContent = code; document.head.appendChild(s); }
  function setStatus(msg)  { const el = document.getElementById('vv-status'); if (el) el.textContent = msg; }

  function hideOverlay() {
    const el = document.getElementById('vv-overlay'); if (!el) return;
    el.classList.add('fade');
    setTimeout(function() { if (el.parentNode) el.parentNode.removeChild(el); }, 550);
  }

  function waitForContent(n) {
    n = n || 0;
    const mc = document.getElementById('mainContent');
    if (mc && mc.children.length > 0 && !mc.querySelector('.loading-state')) { hideOverlay(); return; }
    if (n > 10  && !document.getElementById('mainContent'))                   { hideOverlay(); return; }
    if (n > 200)                                                               { hideOverlay(); return; }
    setTimeout(function() { waitForContent(n + 1); }, 50);
  }

  const SECTION_READY = { paperjs: function() { return !!(window.paper && window.paper.PaperScope); } };

  function waitFor(fn, cb, n) {
    n = n || 0;
    if (fn()) { cb(); return; }
    if (n > 100) { console.warn('[loader] waitFor timeout'); return; }
    setTimeout(function() { waitFor(fn, cb, n + 1); }, 50);
  }

  function runSection(s) {
    const r = SECTION_READY[s.type];
    if (r) waitFor(r, function() { runScript(s.code); }); else runScript(s.code);
  }

  // ── Sass ─────────────────────────────────────────────────────────────────────
  let _sassReady = false; let _sassQ = [];
  function loadSass(fn) {
    if (_sassReady) { fn && fn(); return; }
    if (fn) _sassQ.push(fn);
    if (_sassQ.length > 1 || (!fn && _sassQ.length > 0)) return;
    const s  = document.createElement('script');
    s.src    = 'https://cdn.jsdelivr.net/npm/sass.js@0.11.1/dist/sass.sync.min.js';
    s.onload = function() { _sassReady = true; _sassQ.forEach(c => c()); _sassQ = []; };
    s.onerror= function() { console.warn('[loader] sass.js failed'); };
    document.head.appendChild(s);
  }
  loadSass(null);
  function compileSass(scss, cb) {
    loadSass(function() {
      Sass.compile(scss, function(r) {
        if (r.status === 0) cb(null, r.text); else { console.warn('[loader] Sass:', r.message); cb(r.message, scss); }
      });
    });
  }

  // ── Build inlined HTML ───────────────────────────────────────────────────────
  function buildFromContents(html, contents) {
    let result = html;
    for (const m of [...html.matchAll(/<link\b[^>]*\bhref=["']([^"'#][^"']*)["'][^>]*>/gi)]) {
      const tag = m[0], href = m[1];
      if (/^https?:\/\//i.test(href) || !contents[href]) continue;
      result = result.split(tag).join(
        href.toLowerCase().endsWith('.scss')
          ? '<script type="text/vv-scss">' + contents[href] + '<\/script>'
          : '<style>/* ' + href + ' */\n' + contents[href] + '\n</style>'
      );
    }
    for (const m of [...result.matchAll(/<script\b([^>]*)\bsrc=["']([^"']+)["'][^>]*>\s*<\/script>/gi)]) {
      const tag = m[0], src = m[2];
      if (/^https?:\/\//i.test(src) || !contents[src]) continue;
      result = result.split(tag).join('<script type="text/vv-module" data-name="' + src + '">\n' + contents[src] + '\n<\/script>');
    }
    return result;
  }

  // ── Apply HTML ───────────────────────────────────────────────────────────────
  function applyHTML(inlinedHTML, filename, silent) {
    const doc = new DOMParser().parseFromString(inlinedHTML, 'text/html');
    document.title = doc.title || filename || PROJECT;
    document.head.innerHTML = '';
    doc.head.querySelectorAll(':not(script)').forEach(el => document.head.appendChild(el.cloneNode(true)));
    document.body.innerHTML = '';
    [...doc.body.attributes].forEach(a => document.body.setAttribute(a.name, a.value));
    document.body.innerHTML = doc.body.innerHTML;

    if (!silent) {
      const ov = document.createElement('div'); ov.id = 'vv-overlay';
      ov.innerHTML = '<div id="vv-spinner"></div><div id="vv-status">building&#8230;</div>';
      ov.style.cssText = 'position:fixed;inset:0;z-index:999999;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;transition:opacity 0.5s ease;';
      ov.querySelector('#vv-spinner').style.cssText = 'width:36px;height:36px;border:3px solid rgba(213,159,15,0.2);border-top-color:#D59F0F;border-radius:50%;animation:vv-spin 0.8s linear infinite;';
      ov.querySelector('#vv-status').style.cssText  = 'color:rgba(213,159,15,0.7);font-family:monospace;font-size:12px;letter-spacing:.1em;';
      document.body.appendChild(ov);
    }

    const all = [...doc.head.querySelectorAll('script'), ...doc.body.querySelectorAll('script')];
    function runNext(i) {
      if (i >= all.length) { waitForContent(); return; }
      const orig = all[i]; const type = orig.getAttribute('type') || '';
      if (type === 'text/vv-scss') {
        setStatus('compiling styles&#8230;');
        compileSass(orig.textContent, function(err, css) {
          const st = document.createElement('style'); st.textContent = css;
          document.head.appendChild(st); setStatus('loading scripts&#8230;'); runNext(i + 1);
        });
      } else if (type === 'text/vv-module') {
        parseSections(orig.textContent).forEach(runSection); runNext(i + 1);
      } else if (orig.src) {
        const s = document.createElement('script');
        s.src = orig.src; s.onload = () => runNext(i + 1); s.onerror = () => runNext(i + 1);
        document.head.appendChild(s);
      } else { runScript(orig.textContent); runNext(i + 1); }
    }
    runNext(0);
  }

  // ── Fetch ────────────────────────────────────────────────────────────────────
  async function fetchTab(tabId) {
    const id  = String(tabId).replace(/^t\./, '');
    const url = 'https://docs.google.com/document/d/' + DOC_ID + '/export?format=txt&tab=t.' + id + '&cachebust=' + Date.now();
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error('HTTP ' + res.status + ' for tab t.' + id);
    return (await res.text()).replace(/^\uFEFF/, '').trim();
  }

  async function fetchAllFiles(fileMap, fallback) {
    return Promise.all(Object.keys(fileMap).map(name =>
      fetchTab(fileMap[name]).then(c => ({ name, content: c }))
        .catch(() => ({ name, content: (fallback && fallback[name]) || '' }))
    ));
  }

  function hashStr(s) { let h = 0; for (let i = 0; i < s.length; i++) h = (Math.imul(31, h) + s.charCodeAt(i)) | 0; return h; }

  let _fileMap = {}, _contents = {}, _hashes = {}, _htmlFilename = '', _pollUpdating = false;

  async function pollForChanges() {
    if (_pollUpdating) return; _pollUpdating = true;
    try {
      const fetched = await fetchAllFiles(_fileMap, _contents);
      const fh = {}; let changed = false;
      fetched.forEach(f => { fh[f.name] = hashStr(f.content); if (fh[f.name] !== _hashes[f.name]) changed = true; });
      if (!changed) return;
      console.log('[hotreload] rebuilding');
      const fc = {};
      fetched.forEach(f => { fc[f.name] = _contents[f.name] = f.content; _hashes[f.name] = fh[f.name]; });
      if (fc[_htmlFilename]) applyHTML(buildFromContents(fc[_htmlFilename], fc), _htmlFilename, true);
    } catch(e) { console.warn('[hotreload]', e.message); } finally { _pollUpdating = false; }
  }

  const CACHE_KEY     = 'vv_fm_v3_'  + PROJECT;
  const CACHE_KEY_CON = 'vv_con_v3_' + PROJECT;
  const _prefetchDir  = fetchTab(INDEX_TAB);

  async function resolveFileMap() {
    try {
      const c = store.get(CACHE_KEY);
      if (c) { console.log('[loader] from cache'); return JSON.parse(c); }
    } catch(e) {}

    const dirText = await _prefetchDir;
    const parsed  = parseATCMap(dirText, PROJECT);

    if (!parsed || !parsed.fileMap)
      throw new Error('Parse failed for "' + PROJECT + '". Received ' + dirText.length + ' chars — first 120: ' + JSON.stringify(dirText.slice(0, 120)));
    if (!parsed.htmlFilename)
      throw new Error('No #INDEX HTML found for "' + PROJECT + '"');

    store.set(CACHE_KEY, JSON.stringify(parsed));
    return parsed;
  }

  async function boot() {
    try {
      const { fileMap, htmlFilename } = await resolveFileMap();
      _htmlFilename = htmlFilename;

      let fromCache = false;
      try {
        const cc = store.get(CACHE_KEY_CON);
        if (cc) {
          const ac = JSON.parse(cc);
          if (ac[htmlFilename]) {
            _fileMap = fileMap;
            Object.assign(_contents, ac);
            Object.keys(ac).forEach(k => _hashes[k] = hashStr(ac[k]));
            applyHTML(buildFromContents(ac[htmlFilename], ac), htmlFilename);
            setInterval(pollForChanges, POLL_MS);
            fromCache = true;
          }
        }
      } catch(e) {}

      if (fromCache) {
        fetchAllFiles(fileMap, {}).then(fetched => {
          const f = {}; fetched.forEach(x => { f[x.name] = x.content; });
          store.set(CACHE_KEY_CON, JSON.stringify(f));
        });
        return;
      }

      const fetched = await fetchAllFiles(fileMap, {});
      const ac = {};
      fetched.forEach(f => { ac[f.name] = _contents[f.name] = f.content; _hashes[f.name] = hashStr(f.content); });
      _fileMap = fileMap;
      store.set(CACHE_KEY_CON, JSON.stringify(ac));
      setStatus('fetching styles&#8230;');
      applyHTML(buildFromContents(ac[htmlFilename], ac), htmlFilename);
      setInterval(pollForChanges, POLL_MS);
      console.log('[deploy] "' + PROJECT + '" live');

    } catch(e) {
      document.body.innerHTML =
        '<div style="color:#e07070;font-family:monospace;padding:40px;background:#0c0e12;min-height:100vh">' +
        '<b>&#9888; ' + e.message.replace(/</g,'&lt;') + '</b></div>';
    }
  }

  boot();
</script>
</body>
</html>
