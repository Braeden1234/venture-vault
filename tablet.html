<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading…</title>
  <style>
    body { margin:0; background:#000; display:flex; align-items:center; justify-content:center; height:100vh; }
    #splash { color:#888; font-family:monospace; font-size:13px; letter-spacing:.05em; }
  </style>
</head>
<body>
  <div id="splash">loading…</div>
<script>
  const DOC_ID    = '1LXh4gM2EIcpIvfVmV6F38g3dl8TpjQG_vyecAOa3Dw0';
  const PROJECT   = 'TabletDisplay';
  const INDEX_TAB = '0';
  const POLL_MS   = 5000;

  async function fetchTab(tabId) {
    const id  = String(tabId).replace(/^t\./, '');
    const url = `https://docs.google.com/document/d/${DOC_ID}/export?format=txt&tab=t.${id}&cachebust=${Date.now()}`;
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for tab t.${id}`);
    return (await res.text()).replace(/^\uFEFF/, '').trim();
  }

  function parseKV(text) {
    const map = {};
    for (const raw of text.split('\n')) {
      const line = raw.trim().replace(/^[_*]+|[_*]+(?==)/g, '');
      if (!line || line.startsWith('#') || line.startsWith('//')) continue;
      const eq = line.indexOf('=');
      if (eq < 1) continue;
      const k = line.slice(0, eq).trim().replace(/^[_*]+|[_*]+$/g, '');
      const v = line.slice(eq + 1).trim().replace(/^[_*]+|[_*]+$/g, '');
      if (k && v) map[k] = v;
    }
    return map;
  }

  // ── Parse @section directives out of a JS file ──────────────────────────────
  // // @section:main      → run immediately
  // // @section:paperjs   → run only after paper.js CDN is loaded
  // // @/section          → closes the block
  // Any code outside a section block runs immediately (backwards compatible)
  function parseSections(jsText) {
    const sections = [];
    const lines    = jsText.split('\n');
    let current    = null;
    let buffer     = [];

    for (const line of lines) {
      const trimmed = line.trim();
      const openMatch  = trimmed.match(/^\/\/\s*@section:(\S+)/);
      const closeMatch = trimmed.match(/^\/\/\s*@\/section/);

      if (openMatch) {
        // Save any buffered code before this section as 'main'
        if (buffer.length && buffer.join('\n').trim()) {
          sections.push({ type: 'main', code: buffer.join('\n') });
        }
        buffer  = [];
        current = openMatch[1]; // 'main' | 'paperjs' | etc
      } else if (closeMatch && current) {
        sections.push({ type: current, code: buffer.join('\n') });
        buffer  = [];
        current = null;
      } else {
        buffer.push(line);
      }
    }
    // Remaining buffer after last section
    if (buffer.length && buffer.join('\n').trim()) {
      sections.push({ type: current || 'main', code: buffer.join('\n') });
    }
    return sections;
  }

  // ── Run a script block by injecting it into the document ────────────────────
  function runScript(code) {
    const s = document.createElement('script');
    s.textContent = code;
    document.head.appendChild(s);
  }

  // Map of section type names to a function that returns true when ready.
  // Add new entries here to support other CDN libraries — no changes needed elsewhere.
  var SECTION_READY = {
    'paperjs': function() { return !!(window.paper && window.paper.PaperScope); }
  };

  function waitFor(readyFn, fn, tries) {
    tries = tries || 0;
    if (readyFn()) { fn(); return; }
    if (tries > 100) { console.warn('[loader] timed out waiting for section'); return; }
    setTimeout(function() { waitFor(readyFn, fn, tries + 1); }, 50);
  }

  function runSection(section) {
    var readyFn = SECTION_READY[section.type];
    if (readyFn) {
      waitFor(readyFn, function() { runScript(section.code); });
    } else {
      runScript(section.code);
    }
  }

  // ── Sass compiler (loaded on demand when a .scss file is encountered) ────────
  let _sassReady = false;
  let _sassQueue = [];

  function loadSass(fn) {
    if (_sassReady) { fn(); return; }
    _sassQueue.push(fn);
    if (_sassQueue.length > 1) return; // already loading
    var s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/sass.js@0.11.1/dist/sass.sync.min.js';
    s.onload = function() {
      _sassReady = true;
      _sassQueue.forEach(function(cb) { cb(); });
      _sassQueue = [];
    };
    s.onerror = function() { console.warn('[loader] sass.js failed to load'); };
    document.head.appendChild(s);
  }

  function compileSass(scss, cb) {
    loadSass(function() {
      Sass.compile(scss, function(result) {
        if (result.status === 0) { cb(null, result.text); }
        else { console.warn('[loader] Sass compile error:', result.message); cb(result.message, scss); }
      });
    });
  }

  // ── Inline local CSS/JS into the HTML ───────────────────────────────────────
  // .scss links get a type="text/vv-scss" marker so applyHTML can compile them
  function buildFromContents(htmlContent, contents) {
    let result = htmlContent;
    for (const m of [...htmlContent.matchAll(/<link\b[^>]*\bhref=["']([^"'#][^"']*)["'][^>]*>/gi)]) {
      const fullTag = m[0], href = m[1];
      if (/^https?:\/\//i.test(href) || !contents[href]) continue;
      if (href.toLowerCase().endsWith('.scss')) {
        result = result.split(fullTag).join(`<script type="text/vv-scss">${contents[href]}<\/script>`);
      } else {
        result = result.split(fullTag).join(`<style>/* ${href} */\n${contents[href]}\n</style>`);
      }
    }
    for (const m of [...result.matchAll(/<script\b([^>]*)\bsrc=["']([^"']+)["'][^>]*>\s*<\/script>/gi)]) {
      const fullTag = m[0], src = m[2];
      if (/^https?:\/\//i.test(src) || !contents[src]) continue;
      result = result.split(fullTag).join(
        `<script type="text/vv-module" data-name="${src}">\n${contents[src]}\n<\/script>`
      );
    }
    return result;
  }

  // ── Apply built HTML to the page, respecting @section directives ─────────────
  function applyHTML(inlinedHTML, filename) {
    const doc = new DOMParser().parseFromString(inlinedHTML, 'text/html');
    document.title          = doc.title || filename || PROJECT;
    document.head.innerHTML = '';
    doc.head.querySelectorAll(':not(script)').forEach(el =>
      document.head.appendChild(el.cloneNode(true))
    );
    document.body.innerHTML = '';
    [...doc.body.attributes].forEach(a => document.body.setAttribute(a.name, a.value));
    document.body.innerHTML = doc.body.innerHTML;

    // Collect all scripts in DOM order
    const allScripts = [
      ...doc.head.querySelectorAll('script'),
      ...doc.body.querySelectorAll('script')
    ];

    function runNext(i) {
      if (i >= allScripts.length) return;
      const orig = allScripts[i];
      const type = orig.getAttribute('type') || '';

      if (type === 'text/vv-scss') {
        // Sass file — compile then inject as <style>, continue immediately (async)
        const scss = orig.textContent;
        compileSass(scss, function(err, css) {
          const style = document.createElement('style');
          style.textContent = css;
          document.head.appendChild(style);
        });
        runNext(i + 1);

      } else if (type === 'text/vv-module') {
        const sections = parseSections(orig.textContent);
        sections.forEach(function(sec) { runSection(sec); });
        runNext(i + 1);

      } else if (orig.src) {
        // External CDN script — load it, then continue
        const s = document.createElement('script');
        s.src     = orig.src;
        s.onload  = () => runNext(i + 1);
        s.onerror = () => runNext(i + 1);
        document.head.appendChild(s);

      } else {
        // Normal inline script
        runScript(orig.textContent);
        runNext(i + 1);
      }
    }
    runNext(0);
  }

  async function fetchAllFiles(fileMap, fallback) {
    return Promise.all(
      Object.keys(fileMap).map(name =>
        fetchTab(fileMap[name])
          .then(content => ({ name, content }))
          .catch(() => ({ name, content: (fallback && fallback[name]) || '' }))
      )
    );
  }

  function hashStr(s) {
    let h = 0;
    for (let i = 0; i < s.length; i++) h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;
    return h;
  }

  let _fileMap      = {};
  let _contents     = {};
  let _hashes       = {};
  let _htmlFilename = '';
  let _pollUpdating = false;

  async function pollForChanges() {
    if (_pollUpdating) return;
    _pollUpdating = true;
    try {
      const projectTab = parseKV(await fetchTab(INDEX_TAB))[PROJECT];
      if (!projectTab) return;
      const freshMap = parseKV(await fetchTab(projectTab));
      const fetched  = await fetchAllFiles(freshMap, _contents);

      const freshHashes = {};
      let changed = false;
      fetched.forEach(f => {
        freshHashes[f.name] = hashStr(f.content);
        if (freshHashes[f.name] !== _hashes[f.name]) changed = true;
      });
      if (Object.keys(freshMap).sort().join('|') !== Object.keys(_fileMap).sort().join('|')) changed = true;
      if (!changed) return;

      console.log('[hotreload] change detected — rebuilding');
      const freshContents = {};
      fetched.forEach(f => {
        freshContents[f.name] = f.content;
        _contents[f.name]     = f.content;
        _hashes[f.name]       = freshHashes[f.name];
      });
      _fileMap = freshMap;
      const htmlContent = freshContents[_htmlFilename];
      if (!htmlContent) return;
      applyHTML(buildFromContents(htmlContent, freshContents), _htmlFilename);
    } catch(e) {
      console.warn('[hotreload]', e.message);
    } finally {
      _pollUpdating = false;
    }
  }

  async function boot() {
    try {
      const projectTab = parseKV(await fetchTab(INDEX_TAB))[PROJECT];
      if (!projectTab) throw new Error(`"${PROJECT}" not found`);

      const fileMap = parseKV(await fetchTab(projectTab));
      const htmlFilename = Object.keys(fileMap).find(n => n.toLowerCase().endsWith('.html'));
      if (!htmlFilename) throw new Error(`No .html in "${PROJECT}"`);
      _htmlFilename = htmlFilename;

      const fetched = await fetchAllFiles(fileMap, {});
      const allContents = {};
      fetched.forEach(f => {
        allContents[f.name] = f.content;
        _contents[f.name]   = f.content;
        _hashes[f.name]     = hashStr(f.content);
      });
      _fileMap = fileMap;

      applyHTML(buildFromContents(allContents[htmlFilename], allContents), htmlFilename);
      setInterval(pollForChanges, POLL_MS);
      console.log(`[deploy] "${PROJECT}" live — polling every ${POLL_MS/1000}s`);
    } catch(e) {
      document.body.innerHTML = `
        <div style="color:#e07070;font-family:monospace;padding:40px;background:#0c0e12;min-height:100vh">
          <b>⚠ ${e.message}</b><br><br>
          <span style="color:#555">Check the doc is shared as "Anyone with the link — Viewer"</span>
        </div>`;
    }
  }

  boot();
</script>
</body>
</html>
