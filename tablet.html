<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Loading…</title>
  <!-- Preconnect to hosts we'll definitely hit -->
  <link rel="preconnect" href="https://docs.google.com">
  <link rel="preconnect" href="https://cdn.jsdelivr.net">
  <link rel="preconnect" href="https://docs.googleusercontent.com">
  <!-- Preload sass.js in background immediately — ready before first .scss is needed -->
  <link rel="preload" href="https://cdn.jsdelivr.net/npm/sass.js@0.11.1/dist/sass.sync.min.js" as="script">
  <style>
    body { margin:0; background:#000; }
    #vv-overlay {
      position: fixed;
      inset: 0;
      z-index: 999999;
      background: #000;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 18px;
      transition: opacity 0.5s ease;
    }
    #vv-overlay.fade { opacity: 0; pointer-events: none; }
    #vv-spinner {
      width: 36px;
      height: 36px;
      border: 3px solid rgba(213,159,15,0.2);
      border-top-color: #D59F0F;
      border-radius: 50%;
      animation: vv-spin 0.8s linear infinite;
    }
    #vv-status {
      color: rgba(213,159,15,0.7);
      font-family: monospace;
      font-size: 12px;
      letter-spacing: .1em;
    }
    @keyframes vv-spin { to { transform: rotate(360deg); } }
  </style>
</head>
<body>
  <div id="vv-overlay">
    <div id="vv-spinner"></div>
    <div id="vv-status">loading…</div>
  </div>
<script>
  const DOC_ID    = '1LXh4gM2EIcpIvfVmV6F38g3dl8TpjQG_vyecAOa3Dw0';
  const PROJECT   = 'TabletDisplay';
  const INDEX_TAB = '0';
  const POLL_MS   = 5000;

  async function fetchTab(tabId) {
    const id  = String(tabId).replace(/^t\./, '');
    const url = `https://docs.google.com/document/d/${DOC_ID}/export?format=txt&tab=t.${id}&cachebust=${Date.now()}`;
    const res = await fetch(url, { cache: 'no-store' });
    if (!res.ok) throw new Error(`HTTP ${res.status} for tab t.${id}`);
    return (await res.text()).replace(/^\uFEFF/, '').trim();
  }

  // ── ATC_Map parser ────────────────────────────────────────────────────────────
  // Replaces parseKV(). Handles two tab shapes:
  //
  // Directory tab (FileType Folder):
  //   ATC_Map { % Files { $ FileType (Folder) { .TabletDisplay(@7xqzk0dj9lrp); } } }
  //   → { folderMap: { TabletDisplay: '7xqzk0dj9lrp' } }
  //
  // Project tab (FileType HTML/SCSS/JS/CSS):
  //   ATC_Map { % Files { $ FileType (HTML) #INDEX { .TabletDisplay(@36sh3xer9cvn); } ... } }
  //   → { fileMap: { 'TabletDisplay.html': '36sh3xer9cvn', ... }, htmlFilename: 'TabletDisplay.html' }

  function parseATCMap(text) {
    // Normalize Google Docs formatting noise
    const clean = text
      .replace(/[\u2018\u2019]/g, "'")
      .replace(/[\u201C\u201D]/g, '"')
      .replace(/[_*]/g, '')
      .replace(/\r\n/g, '\n');

    const outerMatch = clean.match(/ATC_Map\s*\{([\s\S]*)\}/);
    if (!outerMatch) return null;

    const filesMatch = outerMatch[1].match(/%\s*Files\s*\{([\s\S]*)\}/);
    if (!filesMatch) return null;
    const filesBlock = filesMatch[1];

    // Directory tab — contains FileType (Folder)
    if (/\(\s*Folder\s*\)/i.test(filesBlock)) {
      const folderMap = {};
      for (const m of filesBlock.matchAll(/\.(\w+)\(@([^)]+)\)/g)) {
        folderMap[m[1]] = m[2];
      }
      return { folderMap };
    }

    // Project tab — one or more $ FileType (EXT) [#INDEX] { ... } blocks
    const fileMap    = {};
    let htmlFilename = null;
    const blockRe    = /\$\s*FileType\s*\(([^)]+)\)((?:\s*#\w+)*)\s*\{([^}]*)\}/g;
    let bm;
    while ((bm = blockRe.exec(filesBlock)) !== null) {
      const ext     = bm[1].trim().toLowerCase();
      const isIndex = bm[2].toUpperCase().includes('#INDEX');
      for (const em of bm[3].matchAll(/\.(\w+)\(@([^)]+)\)/g)) {
        const filename = `${em[1]}.${ext}`;
        fileMap[filename] = em[2];
        if (isIndex) htmlFilename = filename;
      }
    }
    return { fileMap, htmlFilename };
  }

  // ── Parse @section directives out of a JS file ──────────────────────────────
  // // @section:main      → run immediately
  // // @section:paperjs   → run only after paper.js CDN is loaded
  // // @/section          → closes the block
  // Any code outside a section block runs immediately (backwards compatible)
  function parseSections(jsText) {
    const sections = [];
    const lines    = jsText.split('\n');
    let current    = null;
    let buffer     = [];

    for (const line of lines) {
      const trimmed = line.trim();
      const openMatch  = trimmed.match(/^\/\/\s*@section:(\S+)/);
      const closeMatch = trimmed.match(/^\/\/\s*@\/section/);

      if (openMatch) {
        // Save any buffered code before this section as 'main'
        if (buffer.length && buffer.join('\n').trim()) {
          sections.push({ type: 'main', code: buffer.join('\n') });
        }
        buffer  = [];
        current = openMatch[1]; // 'main' | 'paperjs' | etc
      } else if (closeMatch && current) {
        sections.push({ type: current, code: buffer.join('\n') });
        buffer  = [];
        current = null;
      } else {
        buffer.push(line);
      }
    }
    // Remaining buffer after last section
    if (buffer.length && buffer.join('\n').trim()) {
      sections.push({ type: current || 'main', code: buffer.join('\n') });
    }
    return sections;
  }

  // ── Run a script block by injecting it into the document ────────────────────
  function runScript(code) {
    const s = document.createElement('script');
    s.textContent = code;
    document.head.appendChild(s);
  }

  // ── Overlay — stays visible until app signals content is ready ───────────────
  function setStatus(msg) {
    var el = document.getElementById('vv-status');
    if (el) el.textContent = msg;
  }

  function hideOverlay() {
    var el = document.getElementById('vv-overlay');
    if (!el) return;
    el.classList.add('fade');
    setTimeout(function() { if (el.parentNode) el.parentNode.removeChild(el); }, 550);
  }

  // Poll until #mainContent has real content (not just loading state), then hide overlay
  function waitForContent(tries) {
    tries = tries || 0;
    var mc = document.getElementById('mainContent');
    if (mc && mc.children.length > 0 && !mc.querySelector('.loading-state')) {
      hideOverlay();
      return;
    }
    if (tries > 200) { hideOverlay(); return; } // 10s max
    setTimeout(function() { waitForContent(tries + 1); }, 50);
  }

  // Map of section type names to a function that returns true when ready.
  // Add new entries here to support other CDN libraries — no changes needed elsewhere.
  var SECTION_READY = {
    'paperjs': function() { return !!(window.paper && window.paper.PaperScope); }
  };

  function waitFor(readyFn, fn, tries) {
    tries = tries || 0;
    if (readyFn()) { fn(); return; }
    if (tries > 100) { console.warn('[loader] timed out waiting for section'); return; }
    setTimeout(function() { waitFor(readyFn, fn, tries + 1); }, 50);
  }

  function runSection(section) {
    var readyFn = SECTION_READY[section.type];
    if (readyFn) {
      waitFor(readyFn, function() { runScript(section.code); });
    } else {
      runScript(section.code);
    }
  }

  // ── Sass compiler (loaded on demand when a .scss file is encountered) ────────
  let _sassReady = false;
  let _sassQueue = [];

  function loadSass(fn) {
    if (_sassReady) { fn(); return; }
    if (fn) _sassQueue.push(fn);
    if (_sassQueue.length > 1 || (!fn && _sassQueue.length > 0)) return; // already loading
    var s = document.createElement('script');
    s.src = 'https://cdn.jsdelivr.net/npm/sass.js@0.11.1/dist/sass.sync.min.js';
    s.onload = function() {
      _sassReady = true;
      _sassQueue.forEach(function(cb) { cb(); });
      _sassQueue = [];
    };
    s.onerror = function() { console.warn('[loader] sass.js failed to load'); };
    document.head.appendChild(s);
  }

  // Kick off sass.js download immediately in background — ready before first .scss hits
  loadSass(null);

  function compileSass(scss, cb) {
    loadSass(function() {
      Sass.compile(scss, function(result) {
        if (result.status === 0) { cb(null, result.text); }
        else { console.warn('[loader] Sass compile error:', result.message); cb(result.message, scss); }
      });
    });
  }

  // ── Inline local CSS/JS into the HTML ───────────────────────────────────────
  // .scss links get a type="text/vv-scss" marker so applyHTML can compile them
  function buildFromContents(htmlContent, contents) {
    let result = htmlContent;
    for (const m of [...htmlContent.matchAll(/<link\b[^>]*\bhref=["']([^"'#][^"']*)["'][^>]*>/gi)]) {
      const fullTag = m[0], href = m[1];
      if (/^https?:\/\//i.test(href) || !contents[href]) continue;
      if (href.toLowerCase().endsWith('.scss')) {
        result = result.split(fullTag).join(`<script type="text/vv-scss">${contents[href]}<\/script>`);
      } else {
        result = result.split(fullTag).join(`<style>/* ${href} */\n${contents[href]}\n</style>`);
      }
    }
    for (const m of [...result.matchAll(/<script\b([^>]*)\bsrc=["']([^"']+)["'][^>]*>\s*<\/script>/gi)]) {
      const fullTag = m[0], src = m[2];
      if (/^https?:\/\//i.test(src) || !contents[src]) continue;
      result = result.split(fullTag).join(
        `<script type="text/vv-module" data-name="${src}">\n${contents[src]}\n<\/script>`
      );
    }
    return result;
  }

  // ── Apply built HTML to the page, respecting @section directives ─────────────
  function applyHTML(inlinedHTML, filename, silent) {
    const doc = new DOMParser().parseFromString(inlinedHTML, 'text/html');
    document.title          = doc.title || filename || PROJECT;
    document.head.innerHTML = '';
    doc.head.querySelectorAll(':not(script)').forEach(el =>
      document.head.appendChild(el.cloneNode(true))
    );
    document.body.innerHTML = '';
    [...doc.body.attributes].forEach(a => document.body.setAttribute(a.name, a.value));
    document.body.innerHTML = doc.body.innerHTML;

    // Only show black overlay on first boot — hotreload stays invisible so old
    // content remains visible until the new scripts finish executing.
    if (!silent) {
      var _overlay = document.createElement('div');
      _overlay.id = 'vv-overlay';
      _overlay.innerHTML = '<div id="vv-spinner"></div><div id="vv-status">building…</div>';
      _overlay.style.cssText = 'position:fixed;inset:0;z-index:999999;background:#000;display:flex;flex-direction:column;align-items:center;justify-content:center;gap:18px;transition:opacity 0.5s ease;';
      var _spinner = _overlay.querySelector('#vv-spinner');
      _spinner.style.cssText = 'width:36px;height:36px;border:3px solid rgba(213,159,15,0.2);border-top-color:#D59F0F;border-radius:50%;animation:vv-spin 0.8s linear infinite;';
      var _statusEl = _overlay.querySelector('#vv-status');
      _statusEl.style.cssText = 'color:rgba(213,159,15,0.7);font-family:monospace;font-size:12px;letter-spacing:.1em;';
      document.body.appendChild(_overlay);
    }

    // Collect all scripts in DOM order
    const allScripts = [
      ...doc.head.querySelectorAll('script'),
      ...doc.body.querySelectorAll('script')
    ];

    function runNext(i) {
      if (i >= allScripts.length) { waitForContent(); return; }
      const orig = allScripts[i];
      const type = orig.getAttribute('type') || '';

      if (type === 'text/vv-scss') {
        setStatus('compiling styles…');
        const scss = orig.textContent;
        compileSass(scss, function(err, css) {
          const style = document.createElement('style');
          style.textContent = css;
          document.head.appendChild(style);
          setStatus('loading scripts…');
          runNext(i + 1);
        });

      } else if (type === 'text/vv-module') {
        const sections = parseSections(orig.textContent);
        sections.forEach(function(sec) { runSection(sec); });
        runNext(i + 1);

      } else if (orig.src) {
        // External CDN script — load it, then continue
        const s = document.createElement('script');
        s.src     = orig.src;
        s.onload  = () => runNext(i + 1);
        s.onerror = () => runNext(i + 1);
        document.head.appendChild(s);

      } else {
        // Normal inline script
        runScript(orig.textContent);
        runNext(i + 1);
      }
    }
    runNext(0);
  }

  async function fetchAllFiles(fileMap, fallback) {
    return Promise.all(
      Object.keys(fileMap).map(name =>
        fetchTab(fileMap[name])
          .then(content => ({ name, content }))
          .catch(() => ({ name, content: (fallback && fallback[name]) || '' }))
      )
    );
  }

  function hashStr(s) {
    let h = 0;
    for (let i = 0; i < s.length; i++) h = (Math.imul(31, h) + s.charCodeAt(i)) | 0;
    return h;
  }

  let _fileMap      = {};
  let _contents     = {};
  let _hashes       = {};
  let _htmlFilename = '';
  let _pollUpdating = false;

  async function pollForChanges() {
    if (_pollUpdating) return;
    _pollUpdating = true;
    try {
      // Use the already-known file map to fetch current file contents
      const fetched = await fetchAllFiles(_fileMap, _contents);

      const freshHashes = {};
      let changed = false;
      fetched.forEach(f => {
        freshHashes[f.name] = hashStr(f.content);
        if (freshHashes[f.name] !== _hashes[f.name]) changed = true;
      });
      if (!changed) return;

      console.log('[hotreload] change detected — rebuilding');
      const freshContents = {};
      fetched.forEach(f => {
        freshContents[f.name] = f.content;
        _contents[f.name]     = f.content;
        _hashes[f.name]       = freshHashes[f.name];
      });
      const htmlContent = freshContents[_htmlFilename];
      if (!htmlContent) return;
      applyHTML(buildFromContents(htmlContent, freshContents), _htmlFilename, true);
    } catch(e) {
      console.warn('[hotreload]', e.message);
    } finally {
      _pollUpdating = false;
    }
  }

  const CACHE_KEY = 'vv_filemap_' + PROJECT;

  async function resolveFileMap() {
    // Try cache first — skip 2 sequential round trips on repeat loads
    try {
      const cached = sessionStorage.getItem(CACHE_KEY);
      if (cached) {
        const { fileMap, htmlFilename } = JSON.parse(cached);
        console.log('[loader] using cached file map');
        return { fileMap, htmlFilename };
      }
    } catch(e) {}

    // Cold start — Step 1: fetch directory tab → find project folder tab id
    const dirParsed = parseATCMap(await fetchTab(INDEX_TAB));
    if (!dirParsed || !dirParsed.folderMap)
      throw new Error(`Could not parse Directory ATC_Map`);
    const projectTabId = dirParsed.folderMap[PROJECT];
    if (!projectTabId)
      throw new Error(`"${PROJECT}" not found in Directory`);

    // Step 2: fetch project tab → build file map
    const projParsed = parseATCMap(await fetchTab(projectTabId));
    if (!projParsed || !projParsed.fileMap)
      throw new Error(`Could not parse project ATC_Map for "${PROJECT}"`);
    const { fileMap, htmlFilename } = projParsed;
    if (!htmlFilename)
      throw new Error(`No #INDEX HTML entry found for "${PROJECT}"`);

    // Cache for next load
    try { sessionStorage.setItem(CACHE_KEY, JSON.stringify({ fileMap, htmlFilename })); } catch(e) {}
    return { fileMap, htmlFilename };
  }

  async function boot() {
    try {
      const { fileMap, htmlFilename } = await resolveFileMap();
      _htmlFilename = htmlFilename;

      const fetched = await fetchAllFiles(fileMap, {});
      const allContents = {};
      fetched.forEach(f => {
        allContents[f.name] = f.content;
        _contents[f.name]   = f.content;
        _hashes[f.name]     = hashStr(f.content);
      });
      _fileMap = fileMap;

      setStatus('fetching styles…');
      applyHTML(buildFromContents(allContents[htmlFilename], allContents), htmlFilename);
      setInterval(pollForChanges, POLL_MS);
      console.log(`[deploy] "${PROJECT}" live — polling every ${POLL_MS/1000}s`);
    } catch(e) {
      document.body.innerHTML = `
        <div style="color:#e07070;font-family:monospace;padding:40px;background:#0c0e12;min-height:100vh">
          <b>⚠ ${e.message}</b><br><br>
          <span style="color:#555">Check the doc is shared as "Anyone with the link — Viewer"</span>
        </div>`;
    }
  }

  boot();
</script>
</body>
</html>
